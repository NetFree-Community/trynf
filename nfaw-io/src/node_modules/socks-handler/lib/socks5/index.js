var ADDRTYPE, AUTH_METHOD, AUTH_STATUS, COMMAND, REQUEST_STATUS, RSV, VERSION, events, ip, name, net, parsers, through, value, _ref, _ref1,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __slice = [].slice;

net = require('net');

ip = require('ip');

through = require('through');

parsers = require('./parsers');

_ref = require('./const'), VERSION = _ref.VERSION, AUTH_METHOD = _ref.AUTH_METHOD, COMMAND = _ref.COMMAND, AUTH_STATUS = _ref.AUTH_STATUS, ADDRTYPE = _ref.ADDRTYPE, REQUEST_STATUS = _ref.REQUEST_STATUS, RSV = _ref.RSV;

events = {
  handshake: function(_arg, callback) {
    var methods, _ref1;
    methods = _arg.methods;
    if (_ref1 = AUTH_METHOD.NOAUTH, __indexOf.call(methods, _ref1) >= 0) {
      return callback(AUTH_METHOD.NOAUTH);
    } else {
      return callback(AUTH_METHOD.NO_ACCEPTABLE_METHOD);
    }
  },
  auth: function(infos, callback) {
    return callback(AUTH_STATUS.FAILURE);
  },
  request: function(infos, callback) {
    return callback(REQUEST_STATUS.SERVER_FAILURE);
  }
};

exports.createHandler = function() {
  var authMethod, authentication, handler, handshake, name, request, step, value;
  step = 'handshake';
  authMethod = -1;
  handler = through(function(chunk) {
    switch (step) {
      case 'handshake':
        return handshake.call(this, chunk);
      case 'authentication':
        return authentication.call(this, chunk);
      case 'request':
        return request.call(this, chunk);
    }
  });
  handler.version = VERSION;
  for (name in events) {
    value = events[name];
    handler.on(name, value);
  }
  handler.on('newListener', function(event, listener) {
    var _ref1;
    if (event in events && (_ref1 = events[event], __indexOf.call(handler.listeners(event), _ref1) >= 0)) {
      return handler.removeListener(event, events[event]);
    }
  });
  handshake = function(data) {
    var e,
      _this = this;
    try {
      handshake = parsers.handshake(data);
    } catch (_error) {
      e = _error;
      this.emit('error', e);
      return;
    }
    return this.emit('handshake', handshake, function(method) {
      _this.push(new Buffer([VERSION, method]));
      if (method === AUTH_METHOD.NO_ACCEPTABLE_METHOD) {
        return _this.push(null);
      } else if (method === AUTH_METHOD.NOAUTH) {
        return step = 'request';
      } else {
        authMethod = method;
        return step = 'authentication';
      }
    });
  };
  authentication = function(data) {
    var auth, e,
      _this = this;
    try {
      auth = parsers.auth(data, authMethod);
    } catch (_error) {
      e = _error;
      this.emit('error', e);
      return;
    }
    return this.emit('auth', auth, function(status) {
      _this.push(new Buffer([VERSION, status]));
      if (status !== AUTH_STATUS.SUCCESS) {
        return _this.push(null);
      } else {
        return step = 'request';
      }
    });
  };
  request = function(data) {
    var e,
      _this = this;
    try {
      request = parsers.request(data);
    } catch (_error) {
      e = _error;
      this.emit('error', e);
      return;
    }
    return this.emit('request', request, function(status, localPort, localAddress) {
      var addrType, hostBuffer, portBuffer;
      if (localPort) {
        portBuffer = new Buffer(2);
        portBuffer.writeUInt16BE(localPort, 0);
      } else {
        portBuffer = new Buffer([0, 0]);
      }
      if (localAddress) {
        if (net.isIPv4(localAddress)) {
          addrType = ADDRTYPE.IPV4;
          hostBuffer = ip.toBuffer(localAddress);
        } else if (net.isIPv6(localAddress)) {
          addrType = ADDRTYPE.IPV6;
          hostBuffer = ip.toBuffer(localAddress);
        }
      } else {
        addrType = ADDRTYPE.IPV4;
        hostBuffer = new Buffer([0, 0, 0, 0]);
      }
      _this.push(new Buffer([VERSION, status, RSV, addrType].concat(__slice.call(hostBuffer), __slice.call(portBuffer))));
      if (status !== REQUEST_STATUS.SUCCESS) {
        return _this.push(null);
      } else {
        step = 'ignore';
        return _this.emit('success');
      }
    });
  };
  return handler;
};

_ref1 = require('./const');
for (name in _ref1) {
  value = _ref1[name];
  exports[name] = value;
}
